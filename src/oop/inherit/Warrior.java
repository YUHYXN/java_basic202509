package oop.inherit;

// 상속은 클래스 뒤에 쓴다 )) extends 부모클래스이름
// 단일 상속 만 지원한다. (자바는 다중 상속 안됨) 직속 부모는 한 개이다.
public class Warrior extends Player {

    int rage; // 분노 게이지 (전사만 가지는 고유 속성)

    // 전사 클래스의 생성자
    Warrior(String nickname) {
        // 모든 클래스의 생성자에는 super=(); 가 숨어있음
        // 자식의 객체가 생성될 때 부모의 객체도 생성되어야
        // 부모의 속성과 기능이 실존하게 되고, 물려줄 수 있기 때문이다.
        // 근데 Player에게도 부모가 있다 그것은 [Object] 클래스가 부모이다.
        // [Object]는 자바의 최상위 클래스이다.
        super(nickname); // 부모 클래스의 생성자 호출
        // ******** super()는 항상 첫 줄에 있어야 한다.
        // ******** super(nickname); // 이렇게 매개변수 있는 생성자도 호출 가능
        this.rage = 60;

    }

    void dash(){
        System.out.println(this.nickname + "이 돌진 스킬을 사용 합니다.");
    }

     /*
	 # 메서드 오버라이딩(재정의) ****오버로딩 아님!!!
	 - 부모가 물려주는 메서드는 모든 자식들에게 다 맞게 설계되기 힘들기 때문에
	  부족한 점이 있거나, 아예 맞지 않는 경우에는 자식 클래스 쪽에서
	  내용을 추가하거나 수정할 수 있습니다. 이를 오버라이딩 이라고 합니다.

	 - 만약 자식 클래스에서 부모가 물려준 메서드를 새롭게 재 정의한다면
	  자식이 수정한 메서드가 우선적으로 호출됩니다.

     **********************************************************************
	 - 오버라이딩의 규칙이 있습니다. (4가지 모두 일치해야 오버라이딩 인정)  **********
	 ************************************************************
	 그냥 겉모양//틀이 똑같다고 생각하면 됨. 즉, 시그니처가 똑같아야 함.
	 1. 부모가 물려주는 메서드와 이름이 똑같을 것!    **********
	 2. 부모가 물려주는 메서드와 리턴 타입이 똑같을 것! **********
	 3. 부모가 물려주는 메서드와 매개변수의 선언 방식이 똑같을 것!   **********
	 4. 접근제한자는 같거나 more public하게!   **********
	 */

    // 부모가 물려준 것을 내가 커스텀 아래보면 오버라이딩 된 것
    public void characterInfo(){
        // 메서드 오버라이딩을 하면 부모건 무시되고, 자식이 제일 초초우선됨 // 부모꺼 깡그리 무시되긴함
        // 우리는 부모의 기존 속성 깔고 우리꺼만 추가하고싶음
        super.characterInfo(); // 부모의 메서드를 호출하는 구문 그럼 위의 사항을 다 만족한다.
        System.out.println("rage:" + this.rage);
    }



}
